# Model Pattern

Immutable data classes using freezed and json_serializable for serialization.

## Location

- `lib/features/{feature}/domain/{feature}_model.dart` - Domain models
- `lib/features/{feature}/data/{feature}_dto.dart` - API-specific DTOs (when shape differs from domain)

## Key Rules

1. **Use `@freezed` for domain models**: Provides immutability, value equality, `copyWith`, and pattern matching
2. **Use `@JsonSerializable` for simple DTOs**: When you only need serialization without union types or `copyWith`
3. **All fields use `required` unless nullable**: Explicit about what can be absent
4. **Factory constructors for `fromJson`**: Generated by json_serializable build_runner
5. **No business logic in models**: Pure data containers only
6. **`part` directives for generated files**: Both `.freezed.dart` and `.g.dart`

## Freezed Domain Model

```dart
// lib/features/recipes/domain/recipe_model.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'recipe_model.freezed.dart';
part 'recipe_model.g.dart';

@freezed
class Recipe with _$Recipe {
  const factory Recipe({
    required String id,
    required String title,
    required String description,
    required DateTime createdAt,
    DateTime? updatedAt,
  }) = _Recipe;

  factory Recipe.fromJson(Map<String, dynamic> json) =>
      _$RecipeFromJson(json);
}
```

After defining the model, run code generation:
```bash
dart run build_runner build --delete-conflicting-outputs
```

## Request/Response DTOs

Use separate DTOs when the API request shape differs from the domain model.

```dart
// lib/features/recipes/data/recipe_dto.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'recipe_dto.freezed.dart';
part 'recipe_dto.g.dart';

@freezed
class CreateRecipeRequest with _$CreateRecipeRequest {
  const factory CreateRecipeRequest({
    required String title,
    required String description,
  }) = _CreateRecipeRequest;

  factory CreateRecipeRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateRecipeRequestFromJson(json);
}

@freezed
class UpdateRecipeRequest with _$UpdateRecipeRequest {
  const factory UpdateRecipeRequest({
    String? title,
    String? description,
  }) = _UpdateRecipeRequest;

  factory UpdateRecipeRequest.fromJson(Map<String, dynamic> json) =>
      _$UpdateRecipeRequestFromJson(json);
}
```

## JSON Field Name Mapping

When API field names differ from Dart conventions:

```dart
@freezed
class Recipe with _$Recipe {
  const factory Recipe({
    required String id,
    required String title,
    @JsonKey(name: 'created_at') required DateTime createdAt,
    @JsonKey(name: 'updated_at') DateTime? updatedAt,
    @JsonKey(name: 'author_name') required String authorName,
  }) = _Recipe;

  factory Recipe.fromJson(Map<String, dynamic> json) =>
      _$RecipeFromJson(json);
}
```

For project-wide snake_case to camelCase conversion, configure `build.yaml`:

```yaml
# build.yaml
targets:
  $default:
    builders:
      json_serializable:
        options:
          field_rename: snake
```

## Sealed Class for Union Types

Use freezed union types for states or polymorphic data:

```dart
// lib/features/recipes/domain/recipe_status.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'recipe_status.freezed.dart';

@freezed
sealed class RecipeStatus with _$RecipeStatus {
  const factory RecipeStatus.draft() = RecipeStatusDraft;
  const factory RecipeStatus.published({required DateTime publishedAt}) = RecipeStatusPublished;
  const factory RecipeStatus.archived({required String reason}) = RecipeStatusArchived;
}
```

Usage with pattern matching:

```dart
final label = switch (recipe.status) {
  RecipeStatusDraft() => 'Draft',
  RecipeStatusPublished(:final publishedAt) => 'Published on $publishedAt',
  RecipeStatusArchived(:final reason) => 'Archived: $reason',
};
```

## JsonSerializable (Simple DTOs)

When you do not need `copyWith`, union types, or value equality, use `@JsonSerializable` directly:

```dart
// lib/features/recipes/data/paginated_response.dart
import 'package:json_annotation/json_annotation.dart';

part 'paginated_response.g.dart';

@JsonSerializable(genericArgumentFactories: true)
class PaginatedResponse<T> {
  PaginatedResponse({
    required this.items,
    required this.total,
    required this.limit,
    required this.offset,
  });

  final List<T> items;
  final int total;
  final int limit;
  final int offset;

  factory PaginatedResponse.fromJson(
    Map<String, dynamic> json,
    T Function(Object? json) fromJsonT,
  ) => _$PaginatedResponseFromJson(json, fromJsonT);

  Map<String, dynamic> toJson(Object? Function(T value) toJsonT) =>
      _$PaginatedResponseToJson(this, toJsonT);

  bool get hasMore => offset + limit < total;
}
```

## Decision Tree: Freezed vs JsonSerializable

```
Need a data model?
  |-- Does it need copyWith?                  --> @freezed
  |-- Does it need union types?               --> @freezed
  |-- Does it need value equality?            --> @freezed
  |-- Is it a domain model (used in UI state)? --> @freezed
  |-- Is it a simple API request/response DTO? --> @freezed (preferred) or @JsonSerializable
  |-- Is it a generic container (paginated)?   --> @JsonSerializable
  |-- Is it a one-off config/internal struct?  --> Plain Dart class or @JsonSerializable
```

Default to `@freezed` unless you have a specific reason not to.

## Unit Test Example

```dart
// test/unit/features/recipes/recipe_model_test.dart
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('Recipe', () {
    test('fromJson parses valid JSON correctly', () {
      final json = {
        'id': '1',
        'title': 'Pasta',
        'description': 'Delicious pasta',
        'created_at': '2024-01-01T00:00:00.000Z',
        'updated_at': null,
      };

      final recipe = Recipe.fromJson(json);

      expect(recipe.id, equals('1'));
      expect(recipe.title, equals('Pasta'));
      expect(recipe.description, equals('Delicious pasta'));
      expect(recipe.createdAt, equals(DateTime.utc(2024)));
      expect(recipe.updatedAt, isNull);
    });

    test('toJson produces valid JSON', () {
      final recipe = Recipe(
        id: '1',
        title: 'Pasta',
        description: 'Delicious pasta',
        createdAt: DateTime.utc(2024),
      );

      final json = recipe.toJson();

      expect(json['id'], equals('1'));
      expect(json['title'], equals('Pasta'));
    });

    test('copyWith creates new instance with updated fields', () {
      final original = Recipe(
        id: '1',
        title: 'Pasta',
        description: 'Delicious pasta',
        createdAt: DateTime.utc(2024),
      );

      final updated = original.copyWith(title: 'Updated Pasta');

      expect(updated.title, equals('Updated Pasta'));
      expect(updated.id, equals(original.id));
      expect(original.title, equals('Pasta'));
    });

    test('value equality compares all fields', () {
      final a = Recipe(id: '1', title: 'Pasta', description: 'Good', createdAt: DateTime.utc(2024));
      final b = Recipe(id: '1', title: 'Pasta', description: 'Good', createdAt: DateTime.utc(2024));
      final c = Recipe(id: '2', title: 'Soup', description: 'Warm', createdAt: DateTime.utc(2024));

      expect(a, equals(b));
      expect(a, isNot(equals(c)));
    });
  });
}
```

## Anti-Patterns

```dart
// BAD: Mutable class with no equality
class Recipe {
  String id;
  String title;
  Recipe({required this.id, required this.title});
}

// GOOD: Freezed for immutability and equality
@freezed
class Recipe with _$Recipe {
  const factory Recipe({required String id, required String title}) = _Recipe;
  factory Recipe.fromJson(Map<String, dynamic> json) => _$RecipeFromJson(json);
}

// BAD: Business logic in model
@freezed
class Recipe with _$Recipe {
  const Recipe._();
  const factory Recipe({required String id, required String title}) = _Recipe;

  bool get isValid => title.length > 3;  // This belongs in notifier
}

// GOOD: Models are pure data
@freezed
class Recipe with _$Recipe {
  const factory Recipe({required String id, required String title}) = _Recipe;
  factory Recipe.fromJson(Map<String, dynamic> json) => _$RecipeFromJson(json);
}

// BAD: Missing part directives
@freezed
class Recipe with _$Recipe {  // Will fail: no generated code
  const factory Recipe({required String id}) = _Recipe;
}

// GOOD: Include part directives
part 'recipe_model.freezed.dart';
part 'recipe_model.g.dart';

@freezed
class Recipe with _$Recipe {
  const factory Recipe({required String id}) = _Recipe;
  factory Recipe.fromJson(Map<String, dynamic> json) => _$RecipeFromJson(json);
}

// BAD: Using dynamic for JSON parsing
final title = json['title'];  // dynamic

// GOOD: Rely on generated fromJson
final recipe = Recipe.fromJson(json);  // Type-safe
```

## Cross-References

- See `repository.md` for how repositories use `fromJson`/`toJson`
- See `notifier.md` for how notifiers work with model types
- See `screen.md` for how screens display model data
- See `provider.md` for how model types flow through providers
