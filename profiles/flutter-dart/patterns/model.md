# Model Pattern

Immutable data classes using freezed and json_serializable for serialization.

## Location

- `lib/features/{feature}/domain/{feature}_model.dart` - Domain models
- `lib/features/{feature}/data/{feature}_dto.dart` - API-specific DTOs (when shape differs from domain)

## Key Rules

1. **Use `@freezed` for domain models**: Provides immutability, value equality, `copyWith`, and pattern matching
2. **Use `@JsonSerializable` for simple DTOs**: When you only need serialization without union types or `copyWith`
3. **All fields use `required` unless nullable**: Explicit about what can be absent
4. **Factory constructors for `fromJson`**: Generated by json_serializable build_runner
5. **No business logic in models**: Pure data containers only
6. **`part` directives for generated files**: Both `.freezed.dart` and `.g.dart`

## Freezed Domain Model

```dart
// lib/features/recipes/domain/recipe_model.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'recipe_model.freezed.dart';
part 'recipe_model.g.dart';

@freezed
class Recipe with _$Recipe {
  const factory Recipe({
    required String id,
    required String title,
    required String description,
    required DateTime createdAt,
    DateTime? updatedAt,
  }) = _Recipe;

  factory Recipe.fromJson(Map<String, dynamic> json) =>
      _$RecipeFromJson(json);
}
```

After defining the model, run: `dart run build_runner build --delete-conflicting-outputs`

## Request/Response DTOs

```dart
// lib/features/recipes/data/recipe_dto.dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'recipe_dto.freezed.dart';
part 'recipe_dto.g.dart';

@freezed
class CreateRecipeRequest with _$CreateRecipeRequest {
  const factory CreateRecipeRequest({
    required String title,
    required String description,
  }) = _CreateRecipeRequest;

  factory CreateRecipeRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateRecipeRequestFromJson(json);
}
```

## JSON Field Name Mapping

```dart
@freezed
class Recipe with _$Recipe {
  const factory Recipe({
    required String id,
    @JsonKey(name: 'created_at') required DateTime createdAt,
    @JsonKey(name: 'author_name') required String authorName,
  }) = _Recipe;

  factory Recipe.fromJson(Map<String, dynamic> json) => _$RecipeFromJson(json);
}
```

For project-wide snake_case conversion, set `field_rename: snake` in `build.yaml` under `json_serializable` options.

## Sealed Class for Union Types

```dart
@freezed
sealed class RecipeStatus with _$RecipeStatus {
  const factory RecipeStatus.draft() = RecipeStatusDraft;
  const factory RecipeStatus.published({required DateTime publishedAt}) = RecipeStatusPublished;
  const factory RecipeStatus.archived({required String reason}) = RecipeStatusArchived;
}

// Pattern matching usage:
final label = switch (recipe.status) {
  RecipeStatusDraft() => 'Draft',
  RecipeStatusPublished(:final publishedAt) => 'Published on $publishedAt',
  RecipeStatusArchived(:final reason) => 'Archived: $reason',
};
```

## JsonSerializable (Simple DTOs)

When you do not need `copyWith`, union types, or value equality:

```dart
@JsonSerializable(genericArgumentFactories: true)
class PaginatedResponse<T> {
  PaginatedResponse({required this.items, required this.total, required this.limit, required this.offset});

  final List<T> items;
  final int total;
  final int limit;
  final int offset;

  factory PaginatedResponse.fromJson(
    Map<String, dynamic> json, T Function(Object? json) fromJsonT,
  ) => _$PaginatedResponseFromJson(json, fromJsonT);

  Map<String, dynamic> toJson(Object? Function(T value) toJsonT) =>
      _$PaginatedResponseToJson(this, toJsonT);

  bool get hasMore => offset + limit < total;
}
```

## Decision Tree

```
Need copyWith / union types / value equality / domain model? --> @freezed
Generic container or one-off struct?                         --> @JsonSerializable
Default to @freezed unless you have a specific reason not to.
```

## Unit Test Example

```dart
void main() {
  group('Recipe', () {
    test('fromJson parses valid JSON correctly', () {
      final json = {
        'id': '1', 'title': 'Pasta', 'description': 'Delicious pasta',
        'created_at': '2024-01-01T00:00:00.000Z', 'updated_at': null,
      };
      final recipe = Recipe.fromJson(json);
      expect(recipe.id, equals('1'));
      expect(recipe.title, equals('Pasta'));
      expect(recipe.updatedAt, isNull);
    });

    test('copyWith creates new instance with updated fields', () {
      final original = Recipe(
        id: '1', title: 'Pasta', description: 'Delicious', createdAt: DateTime.utc(2024),
      );
      final updated = original.copyWith(title: 'Updated Pasta');
      expect(updated.title, equals('Updated Pasta'));
      expect(original.title, equals('Pasta'));
    });
  });
}
```

## Anti-Patterns

```dart
// BAD: Mutable class with no equality
class Recipe { String id; String title; }

// GOOD: Freezed for immutability and equality
@freezed
class Recipe with _$Recipe {
  const factory Recipe({required String id, required String title}) = _Recipe;
  factory Recipe.fromJson(Map<String, dynamic> json) => _$RecipeFromJson(json);
}

// BAD: Business logic in model
bool get isValid => title.length > 3;  // Belongs in notifier

// BAD: Missing part directives (will fail: no generated code)

// BAD: Using dynamic for JSON parsing
final title = json['title'];  // Use generated fromJson instead
```

## Cross-References

- See `repository.md` for how repositories use `fromJson`/`toJson`
- See `notifier.md` for how notifiers work with model types
- See `screen.md` for how screens display model data
- See `provider.md` for how model types flow through providers
